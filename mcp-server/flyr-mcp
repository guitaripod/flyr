#!/usr/bin/env node

import { spawn } from 'child_process';
import readline from 'readline';

const FLYR_PATH = process.env.FLYR_PATH || 'flyr';

const tools = {
  flyr_search: {
    name: 'flyr_search',
    description: 'Search for flights using Flyr CLI. Flyr searches Google Flights from the terminal. Supports one-way, round-trip, and multi-city itineraries.',
    inputSchema: {
      type: 'object',
      properties: {
        from: {
          type: 'string',
          description: 'Departure airport IATA code (3 letters, e.g., HEL, JFK, LAX). Required unless using leg.'
        },
        to: {
          type: 'string',
          description: 'Arrival airport IATA code(s). Comma-separate for multi-destination (e.g., "BCN,ATH,AYT"). Required unless using leg.'
        },
        date: {
          type: 'string',
          description: 'Departure date in YYYY-MM-DD format. Required unless using leg.'
        },
        return_date: {
          type: 'string',
          description: 'Return date in YYYY-MM-DD format for round-trip flights'
        },
        leg: {
          type: 'array',
          items: {
            type: 'string'
          },
          description: 'Flight legs for multi-city as "DATE FROM TO". Repeat for each leg. Replaces -f/-t/-d when used. Example: ["2026-03-01 LAX NRT", "2026-03-10 NRT LAX"]'
        },
        trip: {
          type: 'string',
          enum: ['one-way', 'round-trip', 'multi-city'],
          default: 'one-way',
          description: 'Trip type: one-way, round-trip, or multi-city'
        },
        seat: {
          type: 'string',
          enum: ['economy', 'premium-economy', 'business', 'first'],
          default: 'economy',
          description: 'Seat class: economy, premium-economy, business, or first'
        },
        max_stops: {
          type: 'number',
          description: 'Maximum number of stops (0 = nonstop only)'
        },
        airlines: {
          type: 'string',
          description: 'Filter airlines by comma-separated IATA codes (e.g., "AY,IB")'
        },
        adults: {
          type: 'number',
          default: 1,
          description: 'Number of adult passengers (12+)'
        },
        children: {
          type: 'number',
          default: 0,
          description: 'Number of child passengers (2-11)'
        },
        infants_in_seat: {
          type: 'number',
          default: 0,
          description: 'Infants with own seat (under 2)'
        },
        infants_on_lap: {
          type: 'number',
          default: 0,
          description: 'Infants on adult lap (under 2)'
        },
        lang: {
          type: 'string',
          default: 'en',
          description: 'Language code (e.g., en, de, ja)'
        },
        currency: {
          type: 'string',
          default: 'USD',
          description: 'Currency code (USD, EUR, JPY, etc.)'
        },
        top: {
          type: 'number',
          description: 'Return only the N cheapest results'
        }
      }
    }
  },
  flyr_get_url: {
    name: 'flyr_get_url',
    description: 'Get the Google Flights URL for a flight search. Use this when you want to open flight results in the browser - call this tool first to get the URL, then use open_url to open it.',
    inputSchema: {
      type: 'object',
      properties: {
        from: {
          type: 'string',
          description: 'Departure airport IATA code (3 letters, e.g., HEL, JFK, LAX). Required unless using leg.'
        },
        to: {
          type: 'string',
          description: 'Arrival airport IATA code(s). Comma-separate for multi-destination (e.g., "BCN,ATH,AYT"). Required unless using leg.'
        },
        date: {
          type: 'string',
          description: 'Departure date in YYYY-MM-DD format. Required unless using leg.'
        },
        return_date: {
          type: 'string',
          description: 'Return date in YYYY-MM-DD format for round-trip flights'
        },
        leg: {
          type: 'array',
          items: {
            type: 'string'
          },
          description: 'Flight legs for multi-city as "DATE FROM TO". Repeat for each leg.'
        },
        trip: {
          type: 'string',
          enum: ['one-way', 'round-trip', 'multi-city'],
          default: 'one-way',
          description: 'Trip type: one-way, round-trip, or multi-city'
        },
        seat: {
          type: 'string',
          enum: ['economy', 'premium-economy', 'business', 'first'],
          default: 'economy',
          description: 'Seat class: economy, premium-economy, business, or first'
        },
        adults: {
          type: 'number',
          default: 1,
          description: 'Number of adult passengers (12+)'
        },
        lang: {
          type: 'string',
          default: 'en',
          description: 'Language code (e.g., en, de, ja)'
        },
        currency: {
          type: 'string',
          default: 'USD',
          description: 'Currency code (USD, EUR, JPY, etc.)'
        }
      },
      required: ['from', 'to', 'date']
    }
  },
  open_url: {
    name: 'open_url',
    description: 'Open a URL in your default web browser. Use this when you want to view a webpage or when a search result provides a link to visit.',
    inputSchema: {
      type: 'object',
      properties: {
        url: {
          type: 'string',
          description: 'The URL to open in the browser (must start with http:// or https://)'
        }
      },
      required: ['url']
    }
  }
};

async function callFlyr(args) {
  return new Promise((resolve, reject) => {
    const argv = ['search'];

    if (args.leg && args.leg.length > 0) {
      for (const leg of args.leg) {
        argv.push('--leg', leg);
      }
    } else {
      if (args.from) argv.push('-f', args.from);
      if (args.to) argv.push('-t', args.to);
      if (args.date) argv.push('-d', args.date);
    }

    if (args.return_date) argv.push('--return-date', args.return_date);
    if (args.trip) argv.push('--trip', args.trip);
    if (args.seat) argv.push('--seat', args.seat);
    if (args.max_stops !== undefined) argv.push('--max-stops', args.max_stops.toString());
    if (args.airlines) argv.push('--airlines', args.airlines);
    if (args.adults) argv.push('--adults', args.adults.toString());
    if (args.children) argv.push('--children', args.children.toString());
    if (args.infants_in_seat) argv.push('--infants-in-seat', args.infants_in_seat.toString());
    if (args.infants_on_lap) argv.push('--infants-on-lap', args.infants_on_lap.toString());
    if (args.lang) argv.push('--lang', args.lang);
    if (args.currency) argv.push('--currency', args.currency);
    if (args.top) argv.push('--top', args.top.toString());

    argv.push('--compact');

    const proc = spawn(FLYR_PATH, argv, {
      env: { ...process.env },
      stdio: ['ignore', 'pipe', 'pipe']
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (d) => { stdout += d; });
    proc.stderr.on('data', (d) => { stderr += d; });

    proc.on('close', (code) => {
      if (code === 0) {
        resolve({ content: [{ type: 'text', text: stdout }] });
      } else {
        reject(new Error(stderr || `flyr exited with code ${code}`));
      }
    });

    proc.on('error', reject);
  });
}

async function getFlyrUrl(args) {
  return new Promise((resolve, reject) => {
    const argv = ['search'];

    if (args.leg && args.leg.length > 0) {
      for (const leg of args.leg) {
        argv.push('--leg', leg);
      }
    } else {
      if (args.from) argv.push('-f', args.from);
      if (args.to) argv.push('-t', args.to);
      if (args.date) argv.push('-d', args.date);
    }

    if (args.return_date) argv.push('--return-date', args.return_date);
    if (args.trip) argv.push('--trip', args.trip);
    if (args.seat) argv.push('--seat', args.seat);
    if (args.adults) argv.push('--adults', args.adults.toString());
    if (args.lang) argv.push('--lang', args.lang);
    if (args.currency) argv.push('--currency', args.currency);

    argv.push('--url');

    const proc = spawn(FLYR_PATH, argv, {
      env: { ...process.env },
      stdio: ['ignore', 'pipe', 'pipe']
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (d) => { stdout += d; });
    proc.stderr.on('data', (d) => { stderr += d; });

    proc.on('close', (code) => {
      if (code === 0) {
        resolve({ content: [{ type: 'text', text: stdout.trim() }] });
      } else {
        reject(new Error(stderr || `flyr exited with code ${code}`));
      }
    });

    proc.on('error', reject);
  });
}

async function openUrl(url) {
  return new Promise((resolve, reject) => {
    const proc = spawn('xdg-open', [url], {
      stdio: 'ignore'
    });

    proc.on('close', (code) => {
      if (code === 0) {
        resolve({ content: [{ type: 'text', text: `Opened ${url} in browser` }] });
      } else {
        reject(new Error(`Failed to open URL: ${url}`));
      }
    });

    proc.on('error', reject);
  });
}

const rl = readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false });

let buffer = '';

process.stdin.on('data', (chunk) => {
  buffer += chunk.toString();
  let newline;
  while ((newline = buffer.indexOf('\n')) !== -1) {
    const line = buffer.slice(0, newline);
    buffer = buffer.slice(newline + 1);
    if (line.trim()) handleMessage(line);
  }
});

function send(msg) {
  process.stdout.write(JSON.stringify(msg) + '\n');
}

function handleMessage(line) {
  let msg;
  try { msg = JSON.parse(line); } catch { return; }

  const id = msg.id;

  if (msg.method === 'initialize') {
    send({
      jsonrpc: '2.0',
      id,
      result: {
        protocolVersion: '2024-11-05',
        capabilities: { tools: {} },
        serverInfo: { name: 'flyr-mcp', version: '1.0.0' }
      }
    });
  }
  else if (msg.method === 'tools/list') {
    send({
      jsonrpc: '2.0',
      id,
      result: { tools: Object.values(tools) }
    });
  }
  else if (msg.method === 'tools/call') {
    const toolName = msg.params.name;
    const toolArgs = msg.params.arguments;

    if (toolName === 'flyr_search') {
      callFlyr(toolArgs)
        .then(result => send({ jsonrpc: '2.0', id, result }))
        .catch(err => send({
          jsonrpc: '2.0',
          id,
          error: { code: -32000, message: err.message }
        }));
    } else if (toolName === 'flyr_get_url') {
      getFlyrUrl(toolArgs)
        .then(result => send({ jsonrpc: '2.0', id, result }))
        .catch(err => send({
          jsonrpc: '2.0',
          id,
          error: { code: -32000, message: err.message }
        }));
    } else if (toolName === 'open_url') {
      openUrl(toolArgs.url)
        .then(result => send({ jsonrpc: '2.0', id, result }))
        .catch(err => send({
          jsonrpc: '2.0',
          id,
          error: { code: -32000, message: err.message }
        }));
    } else {
      send({ jsonrpc: '2.0', id, error: { code: -32601, message: 'Unknown tool' } });
    }
  }
}
